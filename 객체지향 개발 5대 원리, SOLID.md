# SOLID(객체지향 5대원칙)

## SRP(단일책임원칙: Single Responsibility Principle)

-   한 클래스에는 하나의 책임만 가져야 한다.
-   그로인해 책임 영역이 확실진다.
-   책임 영역이 확실해지면?
    -   한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다.
    -   책임을 적절히 분배해서 코드의 가독성을 향상시킨다.
    -   유지보수가 용이해진다.

 <br>

## OCP(개방-폐쇄 원칙: Open Close Principle)

-   확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 한다.
-   즉, 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 한다는 의미.
-   기존 구성요소를 확장해서 재사용 할 수 있어야 한다는 의미이다.
-   확장될 것과, 변화되지 않을 것을 엄격히 구분하고 만약 두 모듈이 만나는 지점이 있다면 인터페이스를 정의한다.
-   어떤 것이 확장될 예정인지, 변화되지 않을 것인지 확신하는 것은 쉽지 않은게 사실이다. 그런 것을 잘 예측하는 것 또한 설계자의 자질 중 하나이다.

 <br>

## LSP(리스코프 치환 원칙: The Liskov Substitution Principle)

-   프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 한다.
-   즉, 서브 타입은 언제나 기반 타입으로 교체될 수 있어야 한다.
-   적용 방법
    -   만약 두 개체가 같은 일을 한다면 둘을 하나의 클래스로 표현하고, 이 둘을 구분할 수 있는 필드를 둔다.
    -   똑같은 연산을 제공하지만 이 둘을 약간씩 다르게 한다면 인터페이스를 만들고 둘이 이를 구현한다.
    -   공통된 연산이 없다면 당연히 이 둘을 별개의 클래스로 쪼갠다.
    -   만약 두 개체가 하는 일에 추가적으로 무언가를 더 한다면 구현 상속을 사용한다.

 <br>

## ISP(인터페이스 분리 원칙: Interface Segregation Principle)

-   클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙이다.
    -   즉, 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
-   특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫다.
-   즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야 한다.
-   SRP가 클래스 분리를 통해 변화의 적응성을 획득하는 반면, ISP는 인터페이스 분리를 통해 획득한다.

 <br>

## DIP(의존관계 역전 원칙: Dependency Inversion Principle)

-   추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙이다.
-   구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙이다.
-   구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전이다.
