# JPA n+1 문제와 해결방법

## JPA n+1 문제

-   연관 관계에서 발생하는 이슈
-   연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수 만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상
-   한두개의 쿼리가 발생하면 큰 차이가 없겠지만
-   대규모 데이터를 갖고있는 서비스에서 이러한 현상이 발생하면 상당히 문제가 심각해진다.

</br>

## 원인은 무엇?

-   FetchType.EAGER
    -   필요하지 않은 데이터까지 한 방에 들고오는 Eager이 문제일까?
    -   문제는 맞다.
    -   하지만 FetchType.LAZY로 한다 해서 문제가 해결되진 않는다.

</br>

-   FetchType.LAZY
    -   이 방식은 연관관계 데이터를 프록시 객체로 바인딩 한다는 것.
    -   하지만 우리는 실제로 연관관계 Entity를 프록시만으로 사용하지 않는다.
    -   결국 LAZY나 EAGER나 N+1 문제를 발생하는 것은 동일하다.
    -   단지, N+1 발생 시점을 연관관계 데이터를 사용하는 시점에 가져올지, 아니면 초기 데이터 로드 시점에 가져오느냐의 차이.

</br>

-   그래서 원인은?
    -   JpaRepository에서 정의한 인터페이스 메서드를 실행하면 JPA는 메서드 이름을 분석하여 JPQL을 생성.
    -   JPQL은 특정 SQL에 종속되지 않고 Entity 객체와 필드 이름을 가지고 쿼리를 작성.
    -   그래서 findAll() 메서드를 수행할 경우 그냥 엔티티 객체 전체를 들고와버림.
    -   그걸 for문을 써서 여러개 부르면 계속 객체 전체를 들고오니까 n+1가 발생하는거.

</br>

## 해결방안

-   Fetch Join

    -   JPQL로 직접 필요한 데이터만 Join 해서 들고오는 방법
    -   이 방법을 사용할 경우 FetchType의 의미가 없어진다.
    -   왜냐면 Fetch Join을 사용하면 호출 시점에 모든 연관 관계의 데이터를 바로 들고와버리기 때문.
    -   Lazy로 설정하나마나 소용이 없다는 뜻.

-   @EntityGraph 와 attributePaths 를 사용한 직접 쿼리 방법
    -   이 방법을 사용하면 필요한 연관관계를 EntityGraph를 이용해서 직접 설정할 수 있다.
    -   Fetch Join과는 다르게 join 문이 outer join으로 실행된다.

reference:

https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1
